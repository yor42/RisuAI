<!-- Virtual Scrolling Component for Svelte 5 with Enhanced Features -->
<div
    bind:this={containerElement}
    class="virtual-scroll-container {className}"
    class:touch-drag-enabled={supportTouchDrag}
    class:touch-dragging={touchDragData?.isDragging}
    style="height: {containerHeight}px; overflow: auto; position: relative;"
    onscroll={handleScroll}
    onmousemove={allowDragScroll ? handleDragAutoScroll : undefined}
>
    <!-- Total height placeholder to maintain scrollbar -->
    <div 
        class="virtual-scroll-spacer" 
        style="height: {totalHeight}px; position: relative;"
    >
        <!-- Rendered items container -->
        <div 
            class="virtual-scroll-content"
            style="position: absolute; top: {offsetY}px; left: 0; right: 0;"
        >
            {#each visibleItems as item, index (item.index)}
                <div 
                    class="virtual-scroll-item"
                    style="position: relative;"
                    bind:this={itemElements[item.index]}
                    data-index={item.index}
                    data-virtual-index={index}
                >
                    {@render children?.(item.data, item.index)}
                </div>
            {/each}
        </div>
    </div>
</div>

<script lang="ts">
    import { untrack } from 'svelte';
    
    interface VirtualItem<T = any> {
        data: T;
        index: number;
        height?: number;
        top?: number;
    }

    interface Props<T = any> {
        items: T[];
        itemHeight: number;
        containerHeight: number;
        overscan?: number;
        className?: string;
        children?: import('svelte').Snippet<[T, number]>;
        onScroll?: (scrollTop: number, scrollDirection: 'up' | 'down') => void;
        scrollDisabled?: boolean;
        allowDragScroll?: boolean;
        dragScrollZone?: number;
        // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ Í¥ÄÎ†® ÏÜçÏÑ±Îì§
        supportTouchDrag?: boolean;
        longPressDelay?: number;
        onTouchDragStart?: (data: any, element: HTMLElement) => void;
        onTouchDragMove?: (data: any, x: number, y: number) => void;
        onTouchDrop?: (sourceData: any, targetData: any) => void;
    }

    let {
        items = [],
        itemHeight = 50,
        containerHeight = 400,
        overscan = 5,
        className = "",
        children,
        onScroll,
        scrollDisabled = false,
        allowDragScroll = false,
        dragScrollZone = 30,
        // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ Í¥ÄÎ†® ÏÜçÏÑ±Îì§
        supportTouchDrag = true,
        longPressDelay = 500,
        onTouchDragStart,
        onTouchDragMove,
        onTouchDrop
    }: Props = $props();

    // Reactive state using Svelte 5 runes
    let containerElement: HTMLDivElement | undefined = $state();
    let itemElements: (HTMLDivElement | undefined)[] = $state([]);
    let scrollTop = $state(0);
    let lastScrollTop = $state(0);
    let itemHeights = $state(new Map<number, number>());
    let itemTops = $state(new Map<number, number>());
    let isScrolling = $state(false);
    let isRecalculating = $state(false);
    let preservedScrollTop = $state<number | null>(null);
    let preservedItemHeights = $state(new Map<number, number>());
    let scrollTimeout: NodeJS.Timeout | undefined = $state();
    let scrollThrottleTimer: NodeJS.Timeout | undefined = $state();
    let isDragging = $state(false);
    let dragAutoScrollTimer: NodeJS.Timeout | undefined = $state();

    // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ Í¥ÄÎ†® ÏÉÅÌÉú Î≥ÄÏàòÎì§
    let touchDragData: {
        element: HTMLElement;
        data: any;
        startX: number;
        startY: number;
        currentX: number;
        currentY: number;
        isDragging: boolean;
    } | null = $state(null);
    let touchPreviewElement: HTMLElement | null = $state(null);
    let longPressTimeout: NodeJS.Timeout | undefined = $state();
    let touchScrollDisabled = $state(false);

    // Track previous items to detect changes
    let previousItems: any[] = $state([]);

    // Derived values
    let totalHeight = $derived.by(() => {
        if (items.length === 0) return 0;
        
        // Calculate total height based on measured heights or estimated height
        let height = 0;
        for (let i = 0; i < items.length; i++) {
            height += itemHeights.get(i) || itemHeight;
        }
        return height;
    });

    let visibleRange = $derived.by(() => {
        if (items.length === 0) return { start: 0, end: 0 };

        let start = 0;
        let end = 0;
        let currentTop = 0;
        
        // Find start index
        for (let i = 0; i < items.length; i++) {
            const height = itemHeights.get(i) || itemHeight;
            if (currentTop + height > scrollTop) {
                start = Math.max(0, i - overscan);
                break;
            }
            currentTop += height;
        }

        // Find end index
        currentTop = 0;
        for (let i = 0; i < items.length; i++) {
            const height = itemHeights.get(i) || itemHeight;
            if (i >= start) {
                itemTops.set(i, currentTop);
            }
            currentTop += height;
            if (currentTop > scrollTop + containerHeight) {
                end = Math.min(items.length, i + 1 + overscan);
                break;
            }
        }

        if (end === 0) end = items.length;

        return { start, end };
    });

    let visibleItems = $derived.by(() => {
        const range = visibleRange;
        const result: VirtualItem[] = [];
        
        for (let i = range.start; i < range.end; i++) {
            if (i >= 0 && i < items.length) {
                result.push({
                    data: items[i],
                    index: i,
                    height: itemHeights.get(i),
                    top: itemTops.get(i)
                });
            }
        }
        
        return result;
    });

    let offsetY = $derived.by(() => {
        const range = visibleRange;
        if (range.start === 0) return 0;
        
        let offset = 0;
        for (let i = 0; i < range.start; i++) {
            offset += itemHeights.get(i) || itemHeight;
        }
        return offset;
    });

    // Handle scroll events with optimized performance
    function handleScroll(event: Event) {
        // ÎìúÎûòÍ∑∏ Ï§ëÏùº Îïå ÏÇ¨Ïö©Ïûê Ïä§ÌÅ¨Î°§ Ï∞®Îã® (ÏûêÎèô Ïä§ÌÅ¨Î°§ÏùÄ ÌóàÏö©)
        if ((scrollDisabled && !isDragging) || touchScrollDisabled) {
            event.preventDefault();
            event.stopPropagation();
            return;
        }
        
        // Ïû¨Í≥ÑÏÇ∞ Ï§ëÏùº Îïå Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î¨¥Ïãú (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
        if (isRecalculating) {
            return;
        }
        
        if (scrollThrottleTimer) {
            return;
        }
        
        scrollThrottleTimer = setTimeout(() => {
            const target = event.target as HTMLElement;
            const newScrollTop = target.scrollTop;
            const direction = newScrollTop > lastScrollTop ? 'down' : 'up';
            
            scrollTop = newScrollTop;
            lastScrollTop = newScrollTop;
            isScrolling = true;
            
            // Call onScroll callback if provided
            onScroll?.(newScrollTop, direction);
            
            // Clear existing timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            // Set scrolling to false after scroll ends
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
                // üîß Ïä§ÌÅ¨Î°§ Î¶¨ÏÖã Î∞©ÏßÄ: Ïä§ÌÅ¨Î°§ ÏúÑÏπò Î≥¥Ï°¥ ÌõÑ measureItems Ïã§Ìñâ
                if (!isRecalculating && containerElement) {
                    const preservedScroll = containerElement.scrollTop;
                    measureItems();
                    // Ï∏°Ï†ï ÌõÑ Ïä§ÌÅ¨Î°§ ÏúÑÏπòÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÎã§Î©¥ Î≥µÏõê
                    requestAnimationFrame(() => {
                        if (containerElement && Math.abs(containerElement.scrollTop - preservedScroll) > 5) {
                            console.log('üîß [SCROLL RESET FIX] Ïä§ÌÅ¨Î°§ ÏúÑÏπò Î≥µÏõê:', {
                                preserved: preservedScroll,
                                current: containerElement.scrollTop,
                                direction: direction
                            });
                            containerElement.scrollTop = preservedScroll;
                        }
                    });
                }
            }, 150);
            
            // Reset throttle timer
            scrollThrottleTimer = undefined;
        }, 8); // 120fps for smooth scrolling
    }

    // Handle drag auto scroll - exported for external use
    export function handleDragAutoScroll(event: MouseEvent) {
        if (!allowDragScroll || !isDragging || !containerElement) return;

        const rect = containerElement.getBoundingClientRect();
        const mouseY = event.clientY - rect.top;
        const scrollSpeed = 5;
        
        // Clear existing auto scroll timer
        if (dragAutoScrollTimer) {
            clearTimeout(dragAutoScrollTimer);
        }

        // Check if mouse is in drag scroll zones
        if (mouseY < dragScrollZone) {
            // Scroll up
            dragAutoScrollTimer = setTimeout(() => {
                if (containerElement && isDragging) {
                    containerElement.scrollTop = Math.max(0, containerElement.scrollTop - scrollSpeed);
                    handleDragAutoScroll(event);
                }
            }, 16);
        } else if (mouseY > containerHeight - dragScrollZone) {
            // Scroll down
            dragAutoScrollTimer = setTimeout(() => {
                if (containerElement && isDragging) {
                    const maxScroll = totalHeight - containerHeight;
                    containerElement.scrollTop = Math.min(maxScroll, containerElement.scrollTop + scrollSpeed);
                    handleDragAutoScroll(event);
                }
            }, 16);
        }
    }

    // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Îì§ - non-passive Î™®ÎìúÎ°ú Îì±Î°ù
    function handleTouchStart(event: TouchEvent, itemData?: any) {
        console.log('üîç [VIRTUAL SCROLL TOUCH] Touch start Ïù¥Î≤§Ìä∏ Î∞úÏÉù');
        
        if (!supportTouchDrag || touchDragData) return;

        const touch = event.touches[0];
        const target = event.currentTarget as HTMLElement;
        
        // ÌÑ∞Ïπò Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        touchDragData = {
            element: target,
            data: itemData,
            startX: touch.clientX,
            startY: touch.clientY,
            currentX: touch.clientX,
            currentY: touch.clientY,
            isDragging: false
        };

        // Í∏∏Í≤å ÌÑ∞Ïπò ÌÉÄÏù¥Î®∏ ÏãúÏûë
        if (longPressTimeout) {
            clearTimeout(longPressTimeout);
        }
        
        longPressTimeout = setTimeout(() => {
            if (touchDragData && !touchDragData.isDragging) {
                startTouchDrag();
                // ÌñÖÌã± ÌîºÎìúÎ∞± (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        }, longPressDelay);

        // Îã§Î•∏ ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î∞©ÏßÄ - non-passiveÏóêÏÑúÎßå ÏûëÎèô
        try {
            event.preventDefault();
            console.log('üîç [VIRTUAL SCROLL TOUCH] preventDefault ÏÑ±Í≥µ (Touch Start)');
        } catch (error) {
            console.error('üîç [VIRTUAL SCROLL TOUCH] preventDefault Ïã§Ìå® (Touch Start):', error);
        }
    }

    function handleTouchMove(event: TouchEvent) {
        console.log('üîç [VIRTUAL SCROLL TOUCH] Touch move Ïù¥Î≤§Ìä∏ Î∞úÏÉù');
        
        if (!touchDragData) return;

        const touch = event.touches[0];
        const moveThreshold = 10; // ÌîΩÏÖÄ Îã®ÏúÑ Ïù¥Îèô ÏûÑÍ≥ÑÍ∞í

        // ÌÑ∞Ïπò ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        touchDragData.currentX = touch.clientX;
        touchDragData.currentY = touch.clientY;

        // Ïù¥Îèô Í±∞Î¶¨ Í≥ÑÏÇ∞
        const deltaX = Math.abs(touch.clientX - touchDragData.startX);
        const deltaY = Math.abs(touch.clientY - touchDragData.startY);

        // Ïù¥Îèô ÏûÑÍ≥ÑÍ∞íÏùÑ Ï¥àÍ≥ºÌïòÎ©¥ Í∏∏Í≤å ÌÑ∞Ïπò ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
        if ((deltaX > moveThreshold || deltaY > moveThreshold) && longPressTimeout) {
            clearTimeout(longPressTimeout);
            longPressTimeout = undefined;
        }

        // ÎìúÎûòÍ∑∏ Ï§ëÏù¥Î©¥ ÎØ∏Î¶¨Î≥¥Í∏∞ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        if (touchDragData.isDragging) {
            updateTouchPreview(touch.clientX, touch.clientY);
            
            // ÏûêÎèô Ïä§ÌÅ¨Î°§ Ï≤òÎ¶¨
            handleTouchAutoScroll(touch.clientY);
            
            // ÏΩúÎ∞± Ìò∏Ï∂ú
            onTouchDragMove?.(touchDragData.data, touch.clientX, touch.clientY);
            
            console.log('üîç [VIRTUAL SCROLL TOUCH] ÎìúÎûòÍ∑∏ Ï§ë - ÎØ∏Î¶¨Î≥¥Í∏∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å');
        }

        // Î∏åÎùºÏö∞Ï†Ä Í∏∞Î≥∏ ÌÑ∞Ïπò ÎèôÏûë Î∞©ÏßÄ - non-passiveÏóêÏÑúÎßå ÏûëÎèô
        try {
            event.preventDefault();
            console.log('üîç [VIRTUAL SCROLL TOUCH] preventDefault ÏÑ±Í≥µ (Touch Move)');
        } catch (error) {
            console.error('üîç [VIRTUAL SCROLL TOUCH] preventDefault Ïã§Ìå® (Touch Move):', error);
        }
    }

    function handleTouchEnd(event: TouchEvent) {
        console.log('üîç [VIRTUAL SCROLL TOUCH] Touch end Ïù¥Î≤§Ìä∏ Î∞úÏÉù');
        
        if (!touchDragData) return;

        // Í∏∏Í≤å ÌÑ∞Ïπò ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
        if (longPressTimeout) {
            clearTimeout(longPressTimeout);
            longPressTimeout = undefined;
        }

        if (touchDragData.isDragging) {
            // ÎìúÎ°≠ Ï≤òÎ¶¨
            const touch = event.changedTouches[0];
            handleTouchDrop(touch.clientX, touch.clientY);
            console.log('üîç [VIRTUAL SCROLL TOUCH] ÌÑ∞Ïπò ÎìúÎ°≠ Ï≤òÎ¶¨ ÏôÑÎ£å');
        }

        // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÏÉÅÌÉú Ï†ïÎ¶¨
        cleanupTouchDrag();
        
        try {
            event.preventDefault();
            console.log('üîç [VIRTUAL SCROLL TOUCH] preventDefault ÏÑ±Í≥µ (Touch End)');
        } catch (error) {
            console.error('üîç [VIRTUAL SCROLL TOUCH] preventDefault Ïã§Ìå® (Touch End):', error);
        }
    }

    function handleTouchCancel(event: TouchEvent) {
        console.log('üîç [VIRTUAL SCROLL TOUCH] Touch cancel Ïù¥Î≤§Ìä∏ Î∞úÏÉù');
        
        // Í∏∏Í≤å ÌÑ∞Ïπò ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
        if (longPressTimeout) {
            clearTimeout(longPressTimeout);
            longPressTimeout = undefined;
        }

        // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÏÉÅÌÉú Ï†ïÎ¶¨
        cleanupTouchDrag();
        
        try {
            event.preventDefault();
            console.log('üîç [VIRTUAL SCROLL TOUCH] preventDefault ÏÑ±Í≥µ (Touch Cancel)');
        } catch (error) {
            console.error('üîç [VIRTUAL SCROLL TOUCH] preventDefault Ïã§Ìå® (Touch Cancel):', error);
        }
    }

    // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÏãúÏûë
    function startTouchDrag() {
        if (!touchDragData) return;

        touchDragData.isDragging = true;
        isDragging = true;
        touchScrollDisabled = true;

        // ÎìúÎûòÍ∑∏ ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÉùÏÑ±
        createTouchPreview();
        
        // ÏΩúÎ∞± Ìò∏Ï∂ú
        onTouchDragStart?.(touchDragData.data, touchDragData.element);
    }

    // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÉùÏÑ±
    function createTouchPreview() {
        if (!touchDragData || touchPreviewElement) return;

        const originalElement = touchDragData.element;
        const clone = originalElement.cloneNode(true) as HTMLElement;
        
        // ÎØ∏Î¶¨Î≥¥Í∏∞ Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        clone.style.position = 'fixed';
        clone.style.zIndex = '9999';
        clone.style.pointerEvents = 'none';
        clone.style.opacity = '0.8';
        clone.style.transform = 'scale(1.05)';
        clone.style.transition = 'none';
        clone.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
        clone.style.border = '2px solid rgba(59, 130, 246, 0.5)';
        clone.style.borderRadius = '8px';
        clone.classList.add('touch-drag-preview');
        
        // Ï¥àÍ∏∞ ÏúÑÏπò ÏÑ§Ï†ï
        updateTouchPreviewPosition(clone, touchDragData.currentX, touchDragData.currentY);
        
        // DOMÏóê Ï∂îÍ∞Ä
        document.body.appendChild(clone);
        touchPreviewElement = clone;
    }

    // ÌÑ∞Ïπò ÎØ∏Î¶¨Î≥¥Í∏∞ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    function updateTouchPreview(x: number, y: number) {
        if (touchPreviewElement) {
            updateTouchPreviewPosition(touchPreviewElement, x, y);
        }
    }

    function updateTouchPreviewPosition(element: HTMLElement, x: number, y: number) {
        const rect = element.getBoundingClientRect();
        element.style.left = `${x - rect.width / 2}px`;
        element.style.top = `${y - rect.height / 2}px`;
    }

    // ÌÑ∞Ïπò ÏûêÎèô Ïä§ÌÅ¨Î°§ Ï≤òÎ¶¨
    function handleTouchAutoScroll(clientY: number) {
        if (!allowDragScroll || !containerElement) return;

        const rect = containerElement.getBoundingClientRect();
        const relativeY = clientY - rect.top;
        const scrollSpeed = 5;

        // ÏûêÎèô Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ Ï≤¥ÌÅ¨
        if (relativeY < dragScrollZone) {
            // ÏúÑÎ°ú Ïä§ÌÅ¨Î°§
            containerElement.scrollTop = Math.max(0, containerElement.scrollTop - scrollSpeed);
        } else if (relativeY > containerHeight - dragScrollZone) {
            // ÏïÑÎûòÎ°ú Ïä§ÌÅ¨Î°§
            const maxScroll = totalHeight - containerHeight;
            containerElement.scrollTop = Math.min(maxScroll, containerElement.scrollTop + scrollSpeed);
        }
    }

    // ÌÑ∞Ïπò ÎìúÎ°≠ Ï≤òÎ¶¨
    function handleTouchDrop(x: number, y: number) {
        if (!touchDragData) return;

        // elementFromPointÎ°ú ÎìúÎ°≠ ÎåÄÏÉÅ Ï∞æÍ∏∞
        const elementsBelow = document.elementsFromPoint(x, y);
        let dropTarget: HTMLElement | null = null;
        let dropData: any = null;

        // ÎìúÎ°≠ Í∞ÄÎä•Ìïú ÏöîÏÜå Ï∞æÍ∏∞ (spacer ÎòêÎäî Îã§Î•∏ ÎìúÎûòÍ∑∏ Í∞ÄÎä• ÏöîÏÜå)
        for (const element of elementsBelow) {
            const htmlElement = element as HTMLElement;
            
            // ÏûêÏã†ÏùÄ Ï†úÏô∏
            if (htmlElement === touchDragData.element || htmlElement === touchPreviewElement) {
                continue;
            }

            // Ïä§ÌéòÏù¥ÏÑú ÎòêÎäî Í∞ÄÏÉÅ Ïä§ÌÅ¨Î°§ ÏïÑÏù¥ÌÖú Ï∞æÍ∏∞
            if (htmlElement.classList.contains('virtual-scroll-item') ||
                htmlElement.dataset.index !== undefined ||
                htmlElement.dataset.virtualIndex !== undefined) {
                dropTarget = htmlElement;
                // Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Î°úÏßÅ (Sidebar.svelteÏùò Ìå®ÌÑ¥ Ï∞∏Ï°∞)
                const index = htmlElement.dataset.index;
                const virtualIndex = htmlElement.dataset.virtualIndex;
                if (index !== undefined) {
                    dropData = { index: parseInt(index) };
                }
                break;
            }
        }

        // ÎìúÎ°≠ ÏΩúÎ∞± Ìò∏Ï∂ú
        if (dropTarget && dropData) {
            onTouchDrop?.(touchDragData.data, dropData);
        }
    }

    // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÏÉÅÌÉú Ï†ïÎ¶¨
    function cleanupTouchDrag() {
        // ÎØ∏Î¶¨Î≥¥Í∏∞ ÏöîÏÜå Ï†úÍ±∞
        if (touchPreviewElement) {
            touchPreviewElement.remove();
            touchPreviewElement = null;
        }

        // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        touchDragData = null;
        isDragging = false;
        touchScrollDisabled = false;

        // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
        if (longPressTimeout) {
            clearTimeout(longPressTimeout);
            longPressTimeout = undefined;
        }
    }

    // Measure item heights for variable height support
    function measureItems() {
        if (!containerElement || isRecalculating) return;
        
        isRecalculating = true;
        
        const itemNodes = containerElement.querySelectorAll('.virtual-scroll-item');
        let heightsChanged = false;
        
        itemNodes.forEach((node) => {
            const element = node as HTMLElement;
            const index = parseInt(element.dataset.index || '0');
            const currentHeight = itemHeights.get(index);
            const measuredHeight = element.offsetHeight;
            
            if (currentHeight !== measuredHeight) {
                itemHeights.set(index, measuredHeight);
                heightsChanged = true;
            }
        });
        
        // Recalculate item positions if heights changed
        if (heightsChanged) {
            recalculatePositions();
        }
        
        isRecalculating = false;
    }

    // Recalculate item positions - Ïä§ÌÅ¨Î°§ Î¶¨ÏÖã Î∞©ÏßÄ Í∞ïÌôî
    function recalculatePositions() {
        if (isScrolling) {
            console.log('üîß [RECALC SKIP] Ïä§ÌÅ¨Î°§ Ï§ëÏù¥ÎØÄÎ°ú ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞ Ïä§ÌÇµ');
            return; // Ïä§ÌÅ¨Î°§ Ï§ëÏùº ÎïåÎäî Ïû¨Í≥ÑÏÇ∞ÌïòÏßÄ ÏïäÏùå
        }
        
        console.log('üîß [RECALC START] ÏïÑÏù¥ÌÖú ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞ ÏãúÏûë:', {
            itemsLength: items.length,
            currentScrollTop: containerElement?.scrollTop,
            isScrolling,
            isRecalculating
        });
        
        let currentTop = 0;
        for (let i = 0; i < items.length; i++) {
            itemTops.set(i, currentTop);
            currentTop += itemHeights.get(i) || itemHeight;
        }
        
        console.log('üîß [RECALC END] ÏïÑÏù¥ÌÖú ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞ ÏôÑÎ£å:', {
            totalHeight: currentTop,
            scrollTopAfter: containerElement?.scrollTop
        });
    }

    // Preserve scroll position when items change
    function preserveScrollPosition() {
        if (containerElement) {
            preservedScrollTop = containerElement.scrollTop;
            preservedItemHeights = new Map(itemHeights);
        }
    }

    // Restore scroll position after items change
    function restoreScrollPosition() {
        if (preservedScrollTop !== null && containerElement) {
            // Ïú†Ìö®Ìïú Í∏∞Ï°¥ Ï∏°Ï†ïÍ∞íÎì§ÏùÑ Î≥µÏõê
            for (const [index, height] of preservedItemHeights) {
                if (index < items.length) {
                    itemHeights.set(index, height);
                }
            }
            
            // ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞
            recalculatePositions();
            
            // Ïä§ÌÅ¨Î°§ ÏúÑÏπò Î≥µÏõê
            requestAnimationFrame(() => {
                if (containerElement && preservedScrollTop !== null) {
                    containerElement.scrollTop = preservedScrollTop;
                    scrollTop = preservedScrollTop;
                }
            });
            
            preservedScrollTop = null;
        }
    }

    // Items change detection - Îã®ÏàúÌôîÎêú Î≤ÑÏ†Ñ (ÏÑ±Îä• Î¨∏Ï†ú Ìï¥Í≤∞)
    $effect(() => {
        // Îã®ÏàúÌïú items Î≥ÄÍ≤Ω Í∞êÏßÄÎßå ÏàòÌñâ - Ïä§ÌÅ¨Î°§ ÏúÑÏπò Ï°∞Ïûë Ï†úÍ±∞
        if (items.length !== previousItems.length) {
            // ÏïÑÏù¥ÌÖú ÏàòÍ∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÏóêÎßå ÎÜíÏù¥ Ï†ïÎ≥¥ Ï¥àÍ∏∞Ìôî
            itemHeights.clear();
            itemTops.clear();
            
            // ÏïàÏ†ÑÌïú Î∞©ÏãùÏúºÎ°ú previousItems ÏóÖÎç∞Ïù¥Ìä∏
            untrack(() => {
                previousItems = [...items];
            });
        }
    });

    // Safe effect - maintain basic functionality
    $effect(() => {
        if (visibleItems.length > 0 && !isRecalculating) {
            // DOM ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ ÎÜíÏù¥ Ï∏°Ï†ï
            requestAnimationFrame(() => {
                measureItems();
            });
        }
    });

    // Container height change handling - Ïä§ÌÅ¨Î°§ Î¶¨ÏÖã Î∞©ÏßÄ Í∞úÏÑ†
    $effect(() => {
        if (containerElement && containerHeight > 0) {
            const currentScroll = containerElement.scrollTop;
            const isUserScrolling = isScrolling; // ÏÇ¨Ïö©ÏûêÍ∞Ä Ïä§ÌÅ¨Î°§ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
            
            requestAnimationFrame(() => {
                if (!isRecalculating && !isUserScrolling) {
                    console.log('üîß [CONTAINER HEIGHT] Ïª®ÌÖåÏù¥ÎÑà ÎÜíÏù¥ Î≥ÄÍ≤ΩÏúºÎ°ú measureItems Ïã§Ìñâ:', {
                        currentScroll,
                        containerHeight,
                        isScrolling: isUserScrolling
                    });
                    measureItems();
                }
                
                // üîß ÏÇ¨Ïö©Ïûê Ïä§ÌÅ¨Î°§ Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå ÏúÑÏπò Î≥µÏõê
                if (containerElement && !isUserScrolling) {
                    const newScroll = containerElement.scrollTop;
                    if (Math.abs(newScroll - currentScroll) > 5) {
                        console.log('üîß [CONTAINER HEIGHT] Ïä§ÌÅ¨Î°§ ÏúÑÏπò Î≥µÏõê:', {
                            previous: currentScroll,
                            current: newScroll
                        });
                        containerElement.scrollTop = currentScroll;
                    }
                }
            });
        }
    });

    // Tooltip cleanup function
    function cleanupOrphanedTooltips() {
        const tooltipElements = document.querySelectorAll('[data-tippy-root]');
        tooltipElements.forEach((tooltip) => {
            const reference = (tooltip as any)._tippy?.reference;
            if (reference && !containerElement?.contains(reference)) {
                const tippyInstance = (reference as any)._tippy;
                if (tippyInstance) {
                    tippyInstance.destroy();
                }
            }
        });
    }

    // Scroll to specific item
    function scrollToItem(index: number, alignment: 'start' | 'center' | 'end' = 'start') {
        if (!containerElement || index < 0 || index >= items.length) return;
        
        let targetScrollTop = itemTops.get(index) || 0;
        
        if (alignment === 'center') {
            const currentItemHeight = itemHeights.get(index) || itemHeight;
            targetScrollTop -= (containerHeight - currentItemHeight) / 2;
        } else if (alignment === 'end') {
            const currentItemHeight = itemHeights.get(index) || itemHeight;
            targetScrollTop -= containerHeight - currentItemHeight;
        }
        
        const totalHeightValue = totalHeight;
        targetScrollTop = Math.max(0, Math.min(targetScrollTop, totalHeightValue - containerHeight));
        containerElement.scrollTop = targetScrollTop;
    }

    // Scroll to specific offset
    function scrollToOffset(offset: number) {
        if (!containerElement) return;
        const totalHeightValue = totalHeight;
        containerElement.scrollTop = Math.max(0, Math.min(offset, totalHeightValue - containerHeight));
    }

    // Export functions for external use
    export function getScrollElement() {
        return containerElement;
    }

    export function scrollTo(indexOrOffset: number, alignment?: 'start' | 'center' | 'end') {
        if (typeof indexOrOffset === 'number' && indexOrOffset >= 0 && indexOrOffset < items.length) {
            scrollToItem(indexOrOffset, alignment);
        } else {
            scrollToOffset(indexOrOffset);
        }
    }

    export function getVisibleRange() {
        return visibleRange;
    }

    export function forceUpdate() {
        if (!isRecalculating) {
            measureItems();
        }
    }

    export function cleanupTooltips() {
        cleanupOrphanedTooltips();
    }

    // Drag state management functions
    export function setDragging(dragging: boolean) {
        isDragging = dragging;
        if (!dragging && dragAutoScrollTimer) {
            clearTimeout(dragAutoScrollTimer);
            dragAutoScrollTimer = undefined;
        }
    }

    export function getDragging() {
        return isDragging;
    }


    // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ Í¥ÄÎ†® export Ìï®ÏàòÎì§
    export function getTouchDragging() {
        return touchDragData?.isDragging || false;
    }

    export function cancelTouchDrag() {
        cleanupTouchDrag();
    }

    export function setTouchDragSupport(enabled: boolean) {
        supportTouchDrag = enabled;
    }

    // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Îì§ÏùÑ Ïô∏Î∂ÄÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù export
    export function getTouchHandlers() {
        return {
            handleTouchStart,
            handleTouchMove,
            handleTouchEnd,
            handleTouchCancel
        };
    }

    // Non-passive ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ùÏùÑ ÏúÑÌïú $effect
    $effect(() => {
        if (!containerElement || !supportTouchDrag) return;

        console.log('üîç [VIRTUAL SCROLL SETUP] Non-passive ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù');

        // Non-passive ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
        const touchStartHandler = (event: TouchEvent) => handleTouchStart(event);
        const touchMoveHandler = (event: TouchEvent) => handleTouchMove(event);
        const touchEndHandler = (event: TouchEvent) => handleTouchEnd(event);
        const touchCancelHandler = (event: TouchEvent) => handleTouchCancel(event);

        // passive: falseÎ°ú Î™ÖÏãúÏ†ÅÏúºÎ°ú non-passive Î™®Îìú ÏÑ§Ï†ï
        containerElement.addEventListener('touchstart', touchStartHandler, { passive: false });
        containerElement.addEventListener('touchmove', touchMoveHandler, { passive: false });
        containerElement.addEventListener('touchend', touchEndHandler, { passive: false });
        containerElement.addEventListener('touchcancel', touchCancelHandler, { passive: false });

        console.log('üîç [VIRTUAL SCROLL SETUP] Non-passive ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù ÏôÑÎ£å');

        // Ï†ïÎ¶¨ Ìï®Ïàò
        return () => {
            console.log('üîç [VIRTUAL SCROLL SETUP] ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†ïÎ¶¨');
            containerElement?.removeEventListener('touchstart', touchStartHandler);
            containerElement?.removeEventListener('touchmove', touchMoveHandler);
            containerElement?.removeEventListener('touchend', touchEndHandler);
            containerElement?.removeEventListener('touchcancel', touchCancelHandler);
        };
    });

    // Component cleanup
    $effect(() => {
        return () => {
            cleanupOrphanedTooltips();
            cleanupTouchDrag(); // ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÏÉÅÌÉú Ï†ïÎ¶¨ Ï∂îÍ∞Ä
            if (scrollTimeout) clearTimeout(scrollTimeout);
            if (scrollThrottleTimer) clearTimeout(scrollThrottleTimer);
            if (dragAutoScrollTimer) clearTimeout(dragAutoScrollTimer);
        };
    });
</script>

<style>
    .virtual-scroll-container {
        /* Ensure proper scrolling behavior */
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        /* Hardware acceleration for better performance */
        transform: translateZ(0);
        will-change: scroll-position;
        /* GPU Î†àÏù¥Ïñ¥ Î∂ÑÎ¶¨Î°ú Ïä§ÌÅ¨Î°§ ÏÑ±Îä• Ìñ•ÏÉÅ */
        contain: layout style paint;
        /* ÎìúÎûòÍ∑∏ Ï§ë ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù Î∞©ÏßÄ */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    .virtual-scroll-container::-webkit-scrollbar {
        width: 8px;
    }

    .virtual-scroll-container::-webkit-scrollbar-track {
        background: transparent;
    }

    .virtual-scroll-container::-webkit-scrollbar-thumb {
        background-color: rgba(156, 163, 175, 0.5);
        border-radius: 4px;
    }

    .virtual-scroll-container::-webkit-scrollbar-thumb:hover {
        background-color: rgba(156, 163, 175, 0.7);
    }

    .virtual-scroll-spacer {
        /* Maintain proper layout for absolute positioning */
        min-height: 1px;
    }

    .virtual-scroll-content {
        /* Container for visible items */
        will-change: transform;
        /* GPU Í∞ÄÏÜçÏùÑ ÏúÑÌïú ÏµúÏ†ÅÌôî */
        transform: translateZ(0);
        backface-visibility: hidden;
    }

    .virtual-scroll-item {
        /* Individual item styling */
        contain: layout style paint;
        will-change: transform;
        /* Í∞úÎ≥Ñ ÏïÑÏù¥ÌÖú GPU Î†àÏù¥Ïñ¥ Î∂ÑÎ¶¨ */
        transform: translateZ(0);
        backface-visibility: hidden;
        /* ÎìúÎûòÍ∑∏ Ï§ë Î∂ÄÎìúÎü¨Ïö¥ Ï†ÑÌôò */
        transition: transform 0.1s ease-out;
    }

    /* Support for drag and drop */
    .virtual-scroll-item[draggable="true"] {
        cursor: grab;
    }

    .virtual-scroll-item[draggable="true"]:active {
        cursor: grabbing;
    }

    /* Drag scroll zones visual feedback */
    .virtual-scroll-container.drag-scroll-active::before,
    .virtual-scroll-container.drag-scroll-active::after {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: var(--drag-scroll-zone, 30px);
        pointer-events: none;
        z-index: 1000;
        background: linear-gradient(to bottom, rgba(59, 130, 246, 0.1), transparent);
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .virtual-scroll-container.drag-scroll-active::before {
        top: 0;
    }

    .virtual-scroll-container.drag-scroll-active::after {
        bottom: 0;
        transform: rotate(180deg);
    }

    .virtual-scroll-container.drag-scroll-active:hover::before,
    .virtual-scroll-container.drag-scroll-active:hover::after {
        opacity: 1;
    }

    /* Support for tooltips */
    .virtual-scroll-item[data-tooltip] {
        position: relative;
    }

    /* Ïä§ÌÅ¨Î°§ Ï§ë ÏµúÏ†ÅÌôîÎ•º ÏúÑÌïú Ïä§ÌÉÄÏùº */
    .virtual-scroll-container.scrolling .virtual-scroll-item {
        pointer-events: none;
    }

    /* Ïû¨Í≥ÑÏÇ∞ Ï§ëÏùº Îïå ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞± */
    .virtual-scroll-container.recalculating {
        opacity: 0.95;
    }

    /* ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ Í¥ÄÎ†® Ïä§ÌÉÄÏùº */
    .virtual-scroll-container.touch-drag-enabled {
        touch-action: none; /* ÌÑ∞Ïπò Ï†úÏä§Ï≤ò Î∞©ÏßÄ */
    }

    .virtual-scroll-container.touch-dragging {
        overflow: hidden; /* ÎìúÎûòÍ∑∏ Ï§ë Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ */
        user-select: none; /* ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù Î∞©ÏßÄ */
    }

    /* ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÎØ∏Î¶¨Î≥¥Í∏∞ Ïä§ÌÉÄÏùº */
    :global(.touch-drag-preview) {
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        filter: brightness(1.1);
        transform-origin: center;
        transition: transform 0.1s ease-out, opacity 0.1s ease-out;
    }

    /* ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ Ï§ëÏù∏ ÏõêÎ≥∏ ÏöîÏÜå Ïä§ÌÉÄÏùº */
    .virtual-scroll-container.touch-dragging .virtual-scroll-item {
        transition: opacity 0.2s ease-out;
    }

    /* ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÌôúÏÑ±Ìôî Ïãú ÏïÑÏù¥ÌÖú Ìò∏Î≤Ñ Ìö®Í≥º */
    .virtual-scroll-container.touch-drag-enabled .virtual-scroll-item:active {
        background-color: rgba(59, 130, 246, 0.05);
        transform: scale(0.98);
        transition: all 0.1s ease-out;
    }

    /* ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÌôúÏÑ±Ìôî ÌëúÏãú */
    .virtual-scroll-container.touch-drag-enabled::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: -1;
        background: linear-gradient(
            135deg,
            rgba(59, 130, 246, 0.02) 0%,
            transparent 50%,
            rgba(59, 130, 246, 0.02) 100%
        );
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .virtual-scroll-container.touch-drag-enabled:hover::after {
        opacity: 1;
    }

    /* Î™®Î∞îÏùº ÏµúÏ†ÅÌôî */
    @media (hover: none) and (pointer: coarse) {
        .virtual-scroll-container.touch-drag-enabled {
            -webkit-overflow-scrolling: auto; /* iOS Ïä§ÌÅ¨Î°§ ÏµúÏ†ÅÌôî Ìï¥Ï†ú */
        }
        
        .virtual-scroll-container.touch-drag-enabled .virtual-scroll-item {
            -webkit-touch-callout: none; /* iOS Í∏∏Í≤å ÎàÑÎ•¥Í∏∞ Î©îÎâ¥ Î∞©ÏßÄ */
            -webkit-user-select: none;
        }
    }

    /* ÎìúÎûòÍ∑∏ Í∞ÄÎä• ÏòÅÏó≠ ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞± (ÎîîÎ≤ÑÍ∑∏Ïö©) */
    .virtual-scroll-container.touch-drag-enabled.debug-mode .virtual-scroll-item {
        border: 1px dashed rgba(59, 130, 246, 0.2);
        position: relative;
    }

    .virtual-scroll-container.touch-drag-enabled.debug-mode .virtual-scroll-item::before {
        content: 'üëÜ';
        position: absolute;
        top: 2px;
        right: 2px;
        font-size: 12px;
        opacity: 0.5;
        pointer-events: none;
    }
</style>